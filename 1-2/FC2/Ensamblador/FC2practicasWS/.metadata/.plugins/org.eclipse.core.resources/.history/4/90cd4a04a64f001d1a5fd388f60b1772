/*---------------------------------------------------------------------
**
**  Fichero:
**    pr2_b.asm  19/10/2022
**
**    (c) Daniel Báscones García
**    Fundamentos de Computadores II
**    Facultad de Informática. Universidad Complutense de Madrid
**
**  Propósito:
**    Fichero de código para la práctica 2b
**
**  Notas de diseño:
**
**	int mul(int a, int b) {
**	    int res = 0;
**	    while (b > 0) {
**	        res += a;
**	        b--;
**	    }
**	    return res;
**	}
**
**	int dotprod(int[] V, int[] W, int n) {
**	    int acc = 0;
**	    for (int i = 0; i < n; i++) {
**	        acc += mul(V[i], W[i]);
**	    }
**	    return acc;
**	}
**
**	#define N 4
**	int[] A = {3, 5, 1, 9}
**	int[] B = {1, 6, 2, 3}
**
**	int res;
**
**	void main() {
**	    int normA = dotprod(A, A, N);
**	    int normB = dotprod(B, B, N);
**	    if (normA > normB)
**	        res = 0xa;
**	    else
**	        res = 0xb;
**	}
**
**-------------------------------------------------------------------*/

.equ N, 4

.data
A:	.word 3, 5, 1, 9
B:	.word 1, 6, 2, 3

.bss
res:.space 4

.text
.global main
main:
	la a0, A
	la a1, A
	li a2, N
	call dotprod
	mv s0, a0
	la a0, B
	la a1, B
	li a2, N
	call dotprod
	mv s1, a0
	ble s0, s1, m_else
	la a0, res
	m_if:
		li a1, 0xa
		j m_endif
	m_else:
		li a1, 0xb
	m_endif:
		sw a1, 0(a0)
	end:
	j end

dotprod:
	//save regs
	addi sp ,sp , -20
	sw s0 ,( sp)
	sw s1 ,4( sp)
	sw s2 ,8( sp)
	sw s3 ,12( sp)
	sw s4 ,16( sp)

	mv s0, a0	//V
	mv s1, a1	//W
	mv s2, a2
	li s3, 0 	//acc
	li s4, 0 	//index
	dp_for:
		bge s4, s2, dp_for_end
		lw a0, 0(s0)
		lw a1, 0(s1)
		call mul
		add s3, s3, a0
		addi s0, s0, 4
		addi s1, s1, 4
		addi s4, s4, 1
		j dp_for
	dp_for_end:
	mv a0, s3

	lw s0 ,( sp)
	lw s1 ,4( sp)
	lw s2 ,8( sp)
	lw s3 ,12( sp)
	lw s4 ,16( sp)
	addi sp ,sp ,20
	ret


mul:
	li a2, 0 //res
mul_while:
	ble a1, zero, mul_end
	add a2, a2, a0
	addi a1, a1, -1
	j mul_while
	mul_end:
	mv a0, a2
	ret


